# Подготовка к собеседованию на Go-разработчика

Источник вопросов: [Коллеги, вы меня огорчаете](https://habr.com/ru/company/oleg-bunin/blog/521582/).

0. **Fizz Buzz**  
https://play.golang.org/p/vpK4dWVjYFD

```go
package main

import (
	"fmt"
	"strconv"
	"strings"
)

func main() {
	for i := 1; i <= 100; i++ {
		var sb strings.Builder

		if (i % 3) == 0 {
			sb.WriteString("Fizz")
		}

		if (i % 5) == 0 {
			sb.WriteString("Buzz")
		}

		if sb.Len() == 0 {
			sb.WriteString(strconv.Itoa(i))
		}

		fmt.Println(sb.String())
	}
}

```

1. **Go — императивный или декларативный? А в чем разница?**  
Go - это императивный язык программирования.  
В императивных ЯП мы опизсываем как надо решать задачу.  
А в декларативных ЯП мы говорим, что конкретно надо сделать.
Имперптивные ЯП: Go, C++, C#, Java, Python)  
Декларативные ЯП: HTML, CSS, SQL, Dockerfile, Github Actions.

2. **Что такое type switch?**  
[Переключатель типов](https://tour.golang.org/methods/16) сравнивает типы, а не значения. В остальном он аналогичен переключателю выражений.

```go
switch v := i.(type) {
case T:
    // here v has type T
case S:
    // here v has type S
default:
    // no match; here v has the same type as i
}
```  

3. **Как сообщить компилятору, что наш тип реализует интерфейс?**  
Если наш тип реализует все методы интерфейса, значит он реализует этот интерфейс.

4. **Как работает append?**  
Самая распространенная цель массивов в Go - хранить память для срезов. Срез описывает кусок массива.
Как работает Append: если capacity достаточно, базовый массив используется повторно. В противном случае выделяется новый базовый массив достаточной длины и данные копируются.

5. **Какое у slice zero value? Какие операции над ним возможны?**  
Zero value у slice == nil  
Возможные операции: len, cap, append  
- append([]string(nil), "") инициализирует slice пустым значением. != nil. len & cap == 1  
- append([]string(nil), []string(nil)...) slice == nil, len & cap == 0  
- range append([]string(nil), []string(nil)...) в range не войдет, т.к. размер слайса == 0  


6. **Как устроен тип map?**
Map в Go это хэш таблица, позволяющая хранить пары ключ-значение и обладающая следующими функциями: маппинг, вставка, удаление, поиск.  Map in Go не упорядоченная. Место поиска определяется рандомно. Когда мы пытаемся получить значение из мапы, а его там нет, получаем «нулевое значение типа», что в случае числа 0. Map — ссылочный тип и мало объявить переменную, надо ее проинициализировать.  
Buckets - хранилище пар ключ-значение. Если в каждом «ведре» в среднем более 6,5 элементов, происходит увеличение массива buckets.  

[Вот тут](https://habr.com/ru/post/457728/) про мапы можно почитать подробнее на русском.
[А тут от Дэйва Чейни](https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics).


7. **Каков порядок перебора map?**  
Случайным образом.  

*Как получить одно случайное значение из map?*  
The only way to select a random key from a map is to put all the keys into a slice and then pick a random element from that slice. If you need the elements in a truly random order, use rand.Perm() to generate a random permutation of the array and process them in that order.  


8, 9. **Что будет, если читать из закрытого канала? Что будет, если писать в закрытый канал?**  
- A send to a nil channel blocks forever
- A receive from a nil channel blocks forever
- A send to a closed channel panics
- A receive from a closed channel returns the zero value immediately  

Подробнее [в посте Дейва Чейни](https://dave.cheney.net/2014/03/19/channel-axioms).

10. **Как вы отсортируете массив структур по алфавиту по полю Name?**  
С помощью функции sort.SliceStable https://play.golang.org/p/gxTLdq-ZnzW  

Доп. вопрос: конвертация array to slice 
```go
var a [32]byte 
slice := a[:]
```

11. **Что такое сериализация? Зачем она нужна?**
Сериализация — это преобразование объекта или дерева объектов в какой-либо формат с тем, чтобы потом эти объекты можно было восстановить из этого формата. Используется, например, для сохранения состояния программы (то есть, некоторых её объектов) между запусками. Или для передачи данных между различными экземплярами программы (или различными программами), например, по сети.  

Главная идея состоит в том, что сериализованный формат — набор байт или строка, которую можно легко сохранить на диск или передать другому процессу или, например, по сети, в отличие от самого объекта. А значит, задача сохранения объекта/группы объектов при этом сводится к простой задаче сохранения набора байт или строки.  

JSON — один из популярных форматов для сериализации, он текстовый, легковесный и легко читается человеком.  

12. **Сколько времени в минутах займет у вас написание процедуры обращения односвязного списка?**  
10 минут. Вот решение https://play.golang.org/p/l2xTn7dTlen


13. **Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?**  
Каждая библиотека не должна экспортировать интерфейс, и общее правило для определения того, кто должен создавать интерфейс можно описать так:  
*Интерфейс создается потребителем (consumer), а не продюсером (producer).*  

- интерфейсы определяют поведение, статические типы — данные  
- чем больше интерфейс, тем слабее абстракция  
- интерфейс, как правило, создается потребителем.  


14. **Предположим, ваша функция должна возвращать детализированные Recoverable и Fatal ошибки. Как это реализовано в пакете net? Как это надо делать в современном Go?**  


